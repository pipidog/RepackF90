                  ! THIS FILE CONTAINS ALL HAMILTONIAN RELATED SUBROUTINES 
! FOCK STATE ==================================================================  
! **** PURPOSE ****
! GENERATES THE FERMION FOCK STATE 
! **** INPUT VARIABLES ****
! [OCCUP_NUM]: INTEGER, 2XN, TELLS THE LEVELS AND PT # OF EACH SITE
! **** OUTPUT VARIABLES ****
! [FOCK_STATE]: INTEGER, SUM(OCCUP_NUM(2,:))X(C(5,2)XC(4,2)), SHOW OCCUPIED STATES
! **** VERSION ****
! 1/20/2014 FIRST BUILT 
! **** COMMENT **** 
! 1. SCENARIO 
! THE OCCUP_NUM HAS THE FORM, EX: [5,2;4,2], WHICH MEANS YOU HAVE 5 LEVELS AT
! SITE-1 WITH 2 PARTICLE IN IT AND SO ON. THE OUTPUT WILL GIVE YOU THE WHICH
! STATES ARE OCCUPIED. THE STATE ARE LABELED IN TOTAL STATE SERIES. SO, FOR
! THIS CASE, SITE-1:1~5, SITE-2:6~9 AND OBVIOUSLY, THE SIZE OF FOCK_STATE IS
! (TOTAL PARTICLE)X(TOTAL PERMUTAION)
! 2. OVERSIZE PROBLEM
! THE COMBINATORIAL PROBLEM GOES TO EXTREMELY LARGE QUICKLY. TO AVIOD TIS ISSUE,
! TRY TO USE PARTICLE-HOLE ALTERNATIVE LANGUAGE FOR YOUR PROBLEM. EX: UING C(14,4)
! INTTEAD OF C(14,10) WHICH MEANS YOU TAKE OFF 4 PARTICLES RATHER THAN ADDING 10
! PARTICLES. IT WILL HIGHLY REDUCE THE LOADING. HOWEVER, KEEP IN MIND WHAT YOU
! ARE USING! 

SUBROUTINE ML_FOCK_STATE(OCCUP_NUM,OCCUP_NUM_DIM,FOCK_STATE,FOCK_STATE_DIM)
  IMPLICIT NONE
  ! INPUT
  INTEGER :: OCCUP_NUM_DIM(2), FOCK_STATE_DIM(2)
  INTEGER :: OCCUP_NUM(OCCUP_NUM_DIM(1),OCCUP_NUM_DIM(2))
  ! OUTPUT
  INTEGER :: FOCK_STATE(FOCK_STATE_DIM(1),FOCK_STATE_DIM(2))
  ! LOCAL(DUMMY)
  INTEGER :: N, M, P
  ! LOCAL (VALUES) 
  INTEGER :: TOT_SITE=0, TOT_PT=0, TMP_COUNT=0 
  INTEGER :: LOOP_INDEX_TEST=0, TOT_COMB=0, COMB=0 
  ! LOCAL(ARRAYS)
  INTEGER, ALLOCATABLE :: LOOP_INDEX(:,:), LOOP_END(:), SITE_RANGE(:,:)
  ! CLEAN VARIABLES
  FOCK_STATE=0

  ! GENERATES ALL NECESSARY VARIABLES
  TOT_SITE=SIZE(OCCUP_NUM,2)
  TOT_PT=SUM(OCCUP_NUM(2,:))
  TOT_COMB=FOCK_STATE_DIM(2)
  ALLOCATE(LOOP_END(SUM(OCCUP_NUM(2,:)))); LOOP_END=0  
  ALLOCATE(SITE_RANGE(2,SIZE(OCCUP_NUM,2))); SITE_RANGE=0 
    
  DO N=1,TOT_SITE
   SELECT CASE(N)
     CASE(1)
      SITE_RANGE(1,N)=1
     CASE DEFAULT
      SITE_RANGE(1,N)=SITE_RANGE(2,N-1)+1
   END SELECT
   SITE_RANGE(2,N)=SITE_RANGE(1,N)+OCCUP_NUM(2,N)-1
  END DO
  
  ! GENERATES LOOP_END VECTOR
  TMP_COUNT=0
  DO N=1,TOT_SITE
    DO M=1,OCCUP_NUM(2,N)
      TMP_COUNT=TMP_COUNT+1
      LOOP_END(TMP_COUNT)=OCCUP_NUM(1,N)     
    END DO
  END DO
  ALLOCATE(LOOP_INDEX(TOT_PT,PRODUCT(LOOP_END))) ; LOOP_INDEX=0
  CALL ML_NESTED_LOOP(LOOP_END,SHAPE(LOOP_END),LOOP_INDEX,SHAPE(LOOP_INDEX))
  
  ! KICK OUT UNWANTED LOOP_INDEX
  TMP_COUNT=0
  DO N=1,PRODUCT(LOOP_END)
    LOOP_INDEX_TEST=1
        
    DO M=1,TOT_SITE
       IF (SITE_RANGE(1,M)/=SITE_RANGE(2,M)) THEN 
         DO P=SITE_RANGE(1,M)+1,SITE_RANGE(2,M)
          IF (ANY(LOOP_INDEX(SITE_RANGE(1,M):P-1,N)>=LOOP_INDEX(P,N))) THEN 
            LOOP_INDEX_TEST=-1
            EXIT
          END IF
         END DO
       END IF
      IF (LOOP_INDEX_TEST==-1) THEN
        EXIT
      END IF
   END DO    
     IF (LOOP_INDEX_TEST==1) THEN
       TMP_COUNT=TMP_COUNT+1
       FOCK_STATE(:,TMP_COUNT)=LOOP_INDEX(:,N)
     END IF
  END DO
END SUBROUTINE

! FOCK STATE Convert ===========================================================  
! **** PURPOSE ****
! Convert the fock state from calculated result (which labels the occupied state
! only) to  
! **** INPUT VARIABLES ****
! [OCCUP_NUM]: INTEGER, 2XN, TELLS THE LEVELS AND PT # OF EACH SITE
! **** OUTPUT VARIABLES ****
! [FOCK_STATE]: INTEGER, SUM(OCCUP_NUM(2,:))X(C(5,2)XC(4,2)), SHOW OCCUPIED STATES
! **** VERSION ****
! 1/20/2014 FIRST BUILT 
! **** COMMENT **** 