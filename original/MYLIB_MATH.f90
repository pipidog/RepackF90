! THIS FILE CONTAINS ALL MATHEMATICAL SUBROUTINES

! FACTORIAL ====================================================================  
! **** PURPOSE ****
! CALCULATES THE VALUES OF FACTORIAL FUNCTION, EX: N!=N*(N-1)*...*1
! **** INPUT VARIABLES ****
! [N]: INTEGER, 1X1, N-FACTORIAL
! **** OUTPUT VARIABLES ****
! [FACTORIAL]: REAL(KIND=8), 1X1, VALUE OF N!
! **** VERSION ****
! 1/20/2014 FIRST BUILT 
! **** COMMENT **** 
! THE OUTPUT IS A REAL(KIND=8) RATHER THAN AN INTEGER TO ACCOMDATE THE MANY
! DIGITS OF THE CALCULATION

SUBROUTINE ML_FACTORIAL(N,FACTORIAL)
  IMPLICIT NONE
  ! INPUT
  INTEGER, INTENT(IN) :: N  ! INPUT (N>25 MAY GET WRONG!)
  ! OUTPUT VALUES
  REAL(KIND=8), INTENT(OUT) :: FACTORIAL ! OUTPUT
  ! LOCAL(VALUES)
  INTEGER :: I=0
  ! LOCAL (ARRAY)
  INTEGER :: M(N)
    ! CLEAN VARIABLES
    M=0
    FACTORIAL=0.0
    ! START PROGRAM
    M=(/(I,I=1,N)/)
    FACTORIAL=PRODUCT(REAL(M)) 
END SUBROUTINE 

! COMBINATORIAL ================================================================ 
! **** PURPOSE **** 
! CALCULATES THE VALUES OF COMBINATORIAL FUNCTION, EX:C(N,M)
! **** INPUT VARIABLES ****
! [N]: INTEGER, 1X1, N TOTAL BALLS
! [M]: INTEGER, 1X1, M BALLS TO PICK
! **** OUTPUT VARIABLES ****
! [COMB]: REAL(KIND=8), 1X1, TOTAL # OF CHOICES 
! **** VERSION ****
! 1/20/2014 FIRST BUILT 
! **** COMMENT **** 
! 

SUBROUTINE ML_COMBINATORIAL(N,M,COMB)
  IMPLICIT NONE
  ! INPUT
  INTEGER, INTENT(IN) :: N,M  ! INPUT
  ! OUTPUT
  REAL(KIND=8), INTENT(OUT) :: COMB !OUTPUT
  ! LOCAL (VALUES)
  REAL(KIND=8) :: FACT1=0.0, FACT2=0.0, FACT3=0.0 !LOCAL VARIABLES
  ! CLEAN VARIABLES
  COMB=0.0
  ! START PROGRAM 
  CALL ML_FACTORIAL(N,FACT1)
  CALL ML_FACTORIAL(M,FACT2)
  CALL ML_FACTORIAL(N-M,FACT3)
  COMB=FACT1/(FACT2*FACT3)
END SUBROUTINE

! Multi-Combinafactorial =======================================================
! **** PURPOSE **** 
! CALCULATES THE PRODUCT OF MANY COMBINATORIAL FUNCTION, EX:C(N,M)XC(P,Q)...
! **** INPUT VARIABLES ****
! [N]: INTEGER, 1X1, N TOTAL BALLS
! [M]: INTEGER, 1X1, M BALLS TO PICK
! **** OUTPUT VARIABLES ****
! [TOT_COMB]: REAL(KIND=8), 1X1, TOTAL # OF CHOICES 
! **** VERSION ****
! 1/21/2014 FIRST BUILT 
! **** COMMENT **** 
! EX: COMB_INDEX(2,2)  DATA /N,N,P,Q/ 
SUBROUTINE ML_MULTICOMB(COMB_INDEX,COMB_INDEX_DIM,TOT_COMB)
  IMPLICIT NONE
  ! INPUT
  INTEGER, INTENT(IN) :: COMB_INDEX_DIM(2)
  INTEGER, INTENT(IN) :: COMB_INDEX(COMB_INDEX_DIM(1),COMB_INDEX_DIM(2))
  ! OUTPUT
  REAL(KIND=8) :: TOT_COMB
  !LOCAL(DUMMY)
  INTEGER :: N 
  !LOCAL(VALUE)
  INTEGER :: TOT_PICK=0 
  REAL(KIND=8) :: COMB=0.0
  !LOCAL(ARRAY)
  !LOCAL(ALLOCATABLE)
  !CLEAN VARIABLES
  TOT_COMB=0.0; 
  
  ! PROGRAM START
  TOT_COMB=1.0
  TOT_PICK=COMB_INDEX_DIM(2)
  
  DO N=1,TOT_PICK  
   CALL ML_COMBINATORIAL(COMB_INDEX(1,N),COMB_INDEX(2,N),COMB)
   TOT_COMB=TOT_COMB*COMB
  END DO
END SUBROUTINE

! NESTED LOOP ==================================================================  
! **** PURPOSE **** 
! OUTPUT THE INDEICES OF A 1:N NESTED DO LOOP
! **** INPUT VARIABLES ****
! [LOOP_END]: INTEGER, NX1, THE ENDING VALUES OF EACH DO LOOP
! **** OUTPUT VARIABLES ****
! [LOOP_INDEX]: INTEGER, (LOOP_END_DIM)X(PRODUCT(LOOP_END)) 
! **** VERSION ****
! 1/20/2014 FIRST BUILT 
! **** COMMENT ****
! FOR ALGORITHM, SEE MY NOTES
! CREATE A VECTOR FOR LOOP_END, EX: [5,5,4,3,3], THE CODE GENERATES THE INDEX OF
! FIVE NESTED LOOPS, WHICH RANGES FROM 1:5,1:5,1:4,1:3,1:3. SO, LOOP_INDEX HAS
! SIZE OF (# OF LOOP-DEPTH)X(TOT_LOOPS) 
! 
SUBROUTINE ML_NESTED_LOOP(LOOP_END,LOOP_END_DIM,LOOP_INDEX,LOOP_INDEX_DIM)
  IMPLICIT NONE
  ! INPUT
  INTEGER, INTENT(IN) :: LOOP_END_DIM(1), LOOP_INDEX_DIM(2) ! DIMENSION
  INTEGER, INTENT(IN) :: LOOP_END(LOOP_END_DIM(1)) ! INPUT VRIABLE 
  ! OUTPUT
  INTEGER, INTENT(OUT) :: LOOP_INDEX(LOOP_INDEX_DIM(1),LOOP_INDEX_DIM(2))  ! OUTPUT VARIABLE
  ! LOCAL(DUMMY)
  INTEGER :: N, M
  ! LOCAL(VALUES)
  INTEGER :: TOT_DIV=0, TOT_LOOP=0 
  INTEGER :: N_REMAIN=0, PRODUCT_REMAIN=0, N_REMAIN_TMP=0
  ! LOCAL(ALLOCATABLE) 
  INTEGER, ALLOCATABLE :: LOOP_DIV(:), N_QUO(:)
  ! CLEAN VARIABLES
  LOOP_INDEX=0
  
  ! START PROGRAM 
  TOT_LOOP=PRODUCT(LOOP_END)
  TOT_DIV=SIZE(LOOP_END,1)-1
  ALLOCATE(LOOP_DIV(TOT_DIV)); LOOP_DIV=0
  ALLOCATE(N_QUO(TOT_DIV)); N_QUO=0
    
  PRODUCT_REMAIN=TOT_LOOP
  DO N=1,TOT_DIV
    PRODUCT_REMAIN=PRODUCT_REMAIN/LOOP_END(N)
    LOOP_DIV(N)=PRODUCT_REMAIN
  END DO
   
  DO N=1,TOT_LOOP
    N_REMAIN=MOD(N,LOOP_DIV(TOT_DIV))
    SELECT CASE(N_REMAIN)
    CASE(1)
      N_REMAIN_TMP=N
      DO M=1,TOT_DIV
        N_QUO(M)=FLOOR(REAL(N_REMAIN_TMP)/REAL(LOOP_DIV(M)))
        N_REMAIN_TMP=MOD(N_REMAIN_TMP,LOOP_DIV(M))
      END DO
      LOOP_INDEX(1:TOT_DIV,N)=N_QUO(:)+1
      LOOP_INDEX(TOT_DIV+1,N)=N_REMAIN_TMP
    CASE(0)
      LOOP_INDEX(:,N)=LOOP_INDEX(:,N-(LOOP_DIV(TOT_DIV)-1))
      LOOP_INDEX(TOT_DIV+1,N)=LOOP_INDEX(TOT_DIV+1,N)+(LOOP_DIV(TOT_DIV)-1)    
    CASE DEFAULT
      LOOP_INDEX(:,N)=LOOP_INDEX(:,N-(N_REMAIN-1));
      LOOP_INDEX(TOT_DIV+1,N)=LOOP_INDEX(TOT_DIV+1,N)+(N_REMAIN-1);    
    END SELECT
  END DO
END SUBROUTINE

! CLEAN REAL MATRIX =============================================================
! **** PURPOSE **** 
! THIS CODE ERASE THE ELEMENTS OF A REAL MATRIX THAT SMALLER THAN A SPECIFIC VALUE
! **** INPUT VARIABLES ****
! [M]: REAL, (N)X(N), MATRIX TO CLEAN 
! [FLITER]: REAL, 1X1, FLITER VALUE
! **** OUTPUT VARIABLES ****
! [M]: REAL, NXN, MATRIX CLEANED
! **** VERSION ****
! 1/26/2014 FIRST BUILT 
! **** COMMENT ****
! 1. OUTPUT
! THE OUTPUT AND INPUT ARE THE SAME
! 2. TRICK
! YOU CAN USE FLITER=MAX(ABS(M))*10**(-3) TO ELIMIATE RELATIVELY SMALL VALUES

SUBROUTINE ML_CLEAN_RMAT(M,M_DIM,FLITER)
	IMPLICIT NONE
	! DIMENSION
	INTEGER :: M_DIM(2)
	! INPUT
	REAL, INTENT(IN) :: FLITER
	! INPUT / OUTPUT
	REAL, INTENT(INOUT) :: M(M_DIM(1),M_DIM(2))
	
	WHERE(M <= FLITER)
		M=0.0
	END WHERE
END SUBROUTINE

! CLEAN COMPLEX MATRIX =========================================================
! **** PURPOSE **** 
! THIS CODE ERASE THE ELEMENTS OF A COMPLEX MATRIX THAT SMALLER THAN A SPECIFIC VALUE
! REAL AND IMAG PARTS ARE EARSED SEPERATLY
! **** INPUT VARIABLES ****
! [M]: COMPLEX, (N)X(N), MATRIX TO CLEAN 
! **** OUTPUT VARIABLES ****
! [M]: REAL, NXN, MATRIX CLEANED
! **** VERSION ****
! 1/26/2014 FIRST BUILT 
! **** COMMENT ****
! 1. OUTPUT
! THE OUTPUT AND INPUT ARE THE SAME
! 2. TRICK
! YOU CAN USE FLITER=MAX(ABS(M))*10**(-3) TO ELIMIATE RELATIVELY SMALL VALUES

SUBROUTINE ML_CLEAN_CMAT(M,M_DIM,FLITER)
	IMPLICIT NONE
	! DIMENSION
	INTEGER :: M_DIM(2)
	! INPUT
	REAL, INTENT(IN) :: FLITER
	! INPUT / OUTPUT
	COMPLEX, INTENT(INOUT) :: M(M_DIM(1),M_DIM(2))
	! LOCAL(DUMMY)
	INTEGER :: N, P
	! LOCAL(ARRAY)
	REAL :: M_REAL(M_DIM(1),M_DIM(2)), M_IMAG(M_DIM(1),M_DIM(2))
	
	
	M_REAL= REALPART(M)
	M_IMAG= IMAGPART(M)
	
	WHERE(M_REAL <= FLITER)
		M_REAL=0.0
	END WHERE
	WHERE(M_IMAG <= FLITER)
		M_IMAG=0.0
	END WHERE
	M=0
	M=M_REAL+(0.0,1.0)*M_IMAG
	! DO P=1,M_DIM(2)
		! DO N=1,M_DIM(1)
			! M(N,P)=M_REAL(N,P)+(0.0,1.0)*M_IMAG(N,P)
		! END DO
	! END DO
END SUBROUTINE	
	
	

! Block Diagonal ===============================================================
! **** PURPOSE **** 
! THIS CODE REORDER A REAL MATRIX TO AS BLOCK DIAGONAL AS POSSIBLE AND DETERMINE 
! WHETHER THERE IS ANY BLOCK DIAGONAL.  
! **** INPUT VARIABLES ****
! [M_IN]: REAL, (N)X(N), THE MATRIX TO REORDER 
! **** OUTPUT VARIABLES ****
! [M_OUT]: REAL, (N)X(N), THE REORDERED MATRIX
! [BD_LABEL]: INTEGER, (N)X(1), TELLS HOW THE MATRIX IS REORDERED
! [BD_RANGE]: INTEGER, (2)X(N), TELLS THE RANGE OF EACH BLOCK
! **** VERSION ****
! 1/26/2014 FIRST BUILT 
! **** COMMENT ****
! 1. ALGORITHM:
! FIND THE NON-ZERO COULLING OF EACH VECTOR. THEN TRY TO GROUP THEM.
! 2. BD_LABEL:
! ALFER THE REORDERING, IT SHOWS HOW THE VECTORS ARE REORDERED.
! 3. BD_RANGE:
! THIS IS A MATRIX WITH DIMENSION OF (2)X(N). BY DEFAULT, IT IS ZERO EVERYWHERE.
! IF THERE IS ANY BLOCK DIAGONAL, THIS VARIABLE WILL RECORD IT RANGE.
! THEREFORE, IF THERE IS ONLY ONE NON-ZERO COLUMN: /1,N/, IT MEANS THERE IS
! NO ANY BLOCK DIAGONAL. IN CONSTRST, IF ALL THE COLUMN IS NON-ZERO AND THE ELEMENTS
! ARE:/ 1,1; 2,2; 3,3;..../, IT MEANS THIS MATRIX IS TOTALLY DIAGONAL! SO ALL THE
! VECTORS ARE INDEPENDENT AND FORMING A BLOCK BY ITSELF.

SUBROUTINE ML_RBLK_DIAG(M_IN,M_IN_DIM,M_OUT,M_OUT_DIM,BD_LABEL,BD_LABEL_DIM,BD_RANGE,BD_RANGE_DIM)
	IMPLICIT NONE
	! DIMENSION
	INTEGER, INTENT(IN) :: M_IN_DIM(2), M_OUT_DIM(2), BD_LABEL_DIM, BD_RANGE_DIM(2)
	! INPUT
	REAL, INTENT(IN) :: M_IN(M_IN_DIM(1),M_IN_DIM(2))
	! OUTPUT
	REAL, INTENT(OUT) :: M_OUT(M_OUT_DIM(1),M_OUT_DIM(2))
	INTEGER, INTENT(OUT) :: BD_LABEL(BD_LABEL_DIM)
	INTEGER, INTENT(OUT) :: BD_RANGE(BD_RANGE_DIM(1),BD_RANGE_DIM(2))
	! LOCAL(DUMMY)
	INTEGER :: N, M, P
	! LOCAL(VALUE)
	INTEGER :: TOT_VECT
	! LOCAL(ARRAY)
	INTEGER :: TOT_VECT_NZ(M_IN_DIM(1))
	! LOCAL(ALLOCATABLE)
	INTEGER, ALLOCATABLE :: NZ_INDEX(:,:)
	! VARIABLE INITIALIZATION
	M_OUT=0; BD_LABEL=0; BD_RANGE=0; ! OUTPUT
	TOT_VECT_NZ=0; ! ARRAY
	! START PROGRAM 
	
	! CHECK INPUT VARIABLES
	IF (M_IN_DIM(1) /= M_IN_DIM(2)) THEN
		WRITE(*,*) "ERROR IN ML_RBLK_DIAG! 'M_IN' MUST BE A SQUARE MATRIX!"
	END IF
	! GENERATES ALL VARIABLES
	TOT_VECT=M_IN_DIM(1)
	DO N=1,TOT_VECT-1
		TOT_VECT_NZ(N)=COUNT(M_IN(N+1,N:)>=10**(-5))
	END DO
	WRITE(*,*) TOT_VECT_NZ	
	
END SUBROUTINE	



