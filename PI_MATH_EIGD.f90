! EIGENVALUES =================================================================  
! **** PURPOSE ****
! THIS CODE DIAGONALIZE A SYMMETRY/HERMITIAN MATRIX USING DIVIDED-CONQUER ALGORITHM
! IN LAPACK (SSYEVD, CHEEVD)
! **** INPUT VARIABLES ****
! [A]: REAL, NXN, THE MATRIX TO BE DIAGONALIZED
! **** OUTPUT VARIABLES ****
! [EVAL]: REAL, N, THE EIGENVALUES 
! **** VERSION ****
! 2/2/2014 FIRST BUILT 
! 2/4/2014 MAKE A-MATRIX AN INOUT TYPE
! **** COMMENT **** 
! 1. NOTICE: 
! THIS CODE IS JUST AN INTERFACE TO HELP USE TWO LAPACK FUNCTIONS. 
! 2. MEMORY 
! TO SAVE MEMROY,THE INUPT MATIRX WILL BE REPLACED TO EIGENVECTOR 
! MATRIX. IF YOU NEED TO KEEP YOUR ORIGINAL ONE, PLEASE SAVE IT 
! BEFORE ENTERING THE SUBROUTINE.
SUBROUTINE PI_EIGD_SYMAT(A,A_DIM,EVAL,EVAL_DIM)
	IMPLICIT NONE
	! DIMENSION
	INTEGER, INTENT(IN) :: A_DIM(2), EVAL_DIM
	! INPUT
	REAL, INTENT(INOUT) :: A(A_DIM(1),A_DIM(2))
	! OUTPUT
	REAL, INTENT(OUT) :: EVAL(EVAL_DIM)
	! LOCAL (VALUE)
	INTEGER :: INFO, LWORK, LIWORK
	! LOCAL (ARRAY)
	REAL, ALLOCATABLE :: WORK(:)
	INTEGER, ALLOCATABLE :: IWORK(:)
	
	
	! VARIABLE INITIALIZATION ------------------------------------------------- 
	LWORK=-1
	LIWORK=-1
	EVAL=0
	
	! SEARCHING OPTIMAL VALUE FOR LWORK ---------------------------------------
	ALLOCATE(WORK(1))
	ALLOCATE(IWORK(1))
    CALL SSYEVD('V','L',A_DIM(1),A,A_DIM(1),EVAL,WORK,LWORK,IWORK,LIWORK,INFO)
	LWORK=NINT(WORK(1))
	LWORK=LWORK+1
	DEALLOCATE(WORK)
    ALLOCATE(WORK(LWORK))
	LIWORK=IWORK(1)
	LIWORK=LIWORK+1
	DEALLOCATE(IWORK)
    ALLOCATE(IWORK(LIWORK))
	
	
	! DIAGONALIZATION
	CALL SSYEVD('V','L',A_DIM(1),A,A_DIM(1),EVAL,WORK,LWORK,IWORK,LIWORK,INFO)
	IF (INFO/=0) THEN
		WRITE(*,*) "ERROR IN PI_EIGD_RMAT! SSYEV GET INFO/=0!"
		RETURN
	END IF
END SUBROUTINE

! CMAT ========================================================================
! **** INPUT VARIABLES ****
! [A]: COMPLEX, NXN, THE MATRIX TO BE DIAGONALIZED
! **** OUTPUT VARIABLES ****
! [EVAL]: REAL, N, THE EIGENVALUES 

SUBROUTINE PI_EIGD_HEMAT(A,A_DIM,EVAL,EVAL_DIM)
	IMPLICIT NONE
	! DIMENSION
	INTEGER, INTENT(IN) :: A_DIM(2), EVAL_DIM
	! INPUT
	COMPLEX, INTENT(INOUT) :: A(A_DIM(1),A_DIM(2))
	! OUTPUT
	REAL, INTENT(OUT) :: EVAL(EVAL_DIM)
	! LOCAL (VALUE)
	INTEGER :: INFO, LWORK, LRWORK, LIWORK
	! LOCAL (ARRAY)
	COMPLEX, ALLOCATABLE :: WORK(:)
	REAL, ALLOCATABLE :: RWORK(:)
	INTEGER, ALLOCATABLE :: IWORK(:)
	
	
	! VARIABLE INITIALIZATION ------------------------------------------------- 
	LWORK=-1
	LRWORK=-1
	LIWORK=-1
	EVAL=0
	
	! SEARCHING OPTIMAL VALUE FOR LWORK ---------------------------------------
	ALLOCATE(WORK(1))
    CALL CHEEV('V','L',A_DIM(1),A,A_DIM(1),EVAL,WORK,LWORK,RWORK,LRWORK,IWORK,LIWORK,INFO)
	LWORK=NINT(REAL(WORK(1)))
	LWORK=LWORK+1	
	DEALLOCATE(WORK)
    ALLOCATE(WORK(LWORK))
	LRWORK=NINT(RWORK(1))
	LRWORK=LRWORK+1	
	DEALLOCATE(RWORK)
    ALLOCATE(RWORK(LRWORK))
	LIWORK=IWORK(1)
	LIWORK=LIWORK+1	
	DEALLOCATE(IWORK)
    ALLOCATE(IWORK(LIWORK))
	
	! DIAGONALIZATION
	CALL CHEEV('V','L',A_DIM(1),A,A_DIM(1),EVAL,WORK,LWORK,RWORK,LRWORK,IWORK,LIWORK,INFO)
	IF (INFO/=0) THEN
		WRITE(*,*) "ERROR IN PI_EIGD_CMAT! CHEEV GET INFO/=0!"
		RETURN
	END IF
END SUBROUTINE