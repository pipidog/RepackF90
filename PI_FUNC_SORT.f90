!Lexicographical Bubble Sort ===============================================
! **** PURPOSE **** 
! THIS FUNCTION USING BUBBLE SORT ALGORITHM TO REORDER YOUR DATA LEXICOGRAPHICALLY
! **** INPUT VARIABLES ****
! [A]: REAL, NXM, YOUR DATA
! [SORT_TYPE]: 'R'(BASED ON ROW), 'C'(BASED ON COLUMN)
! [ORDER]: 'I'(INCREASING), 'D'(DECREASING)
! **** OUTPUT VARIABLES ****
! [A]: REAL, NXM, RESORTTED DATA
! **** VERSION ****
! 1/31/2014 FIRST BUILT 
! **** COMMENT ****
! INPUT AND OUTPUT ARE THE SAME

SUBROUTINE PI_LSORT_RMAT(A,A_DIM,SORT_TYPE,ORDER)
	IMPLICIT NONE
	! DIMENSION 
	INTEGER, INTENT(IN) :: A_DIM(2)
	! INPUT
	CHARACTER(LEN=*) SORT_TYPE, ORDER
	! INPUT / OUTPUT
	REAL, INTENT(INOUT) :: A(A_DIM(1),A_DIM(2))
	! LOCAL
	REAL, PARAMETER :: ZERO=0.00001
	INTEGER :: N, M, P 
	INTEGER :: A_INDEX, SWAP_MARKER
	REAL, ALLOCATABLE:: TMP_R_V1(:), TMP_R_A1(:,:)
	
	! VARIABLE INITIALIZATION
	CALL PI_CLEAN_RMAT(A,SHAPE(A),ZERO)
	
	! PROGRAM START
	SELECT CASE(SORT_TYPE)
	CASE('C')
		ALLOCATE(TMP_R_V1(A_DIM(1))); TMP_R_V1=0
		ALLOCATE(TMP_R_A1(A_DIM(1),2)); TMP_R_A1=0
		DO M=1,A_DIM(2)-1
			DO N=1,A_DIM(2)-M
				TMP_R_V1=A(:,N+1)-A(:,N)
				SWAP_MARKER=0
				! CHECK IF SWAP
				DO P=1,A_DIM(1)
					IF (TMP_R_V1(P)>ZERO) THEN
						SWAP_MARKER=1
						EXIT
					ELSE IF (TMP_R_V1(P)<-ZERO) THEN
						SWAP_MARKER=-1
						EXIT
					END IF
				END DO
				
				IF (SWAP_MARKER==-1) THEN
					TMP_R_A1(:,1)=A(:,N+1)
					TMP_R_A1(:,2)=A(:,N)
					A(:,N:N+1)=TMP_R_A1
				END IF
			END DO
		END DO
		IF (ORDER=='D') THEN 
			DEALLOCATE(TMP_R_A1)
			ALLOCATE(TMP_R_A1(A_DIM(1),A_DIM(2))); TMP_R_A1=A
			DO N=1,A_DIM(2)
				A(:,A_DIM(2)-N+1)=TMP_R_A1(:,N)
			END DO
		ELSE IF (ORDER=='I') THEN
		
		ELSE
			WRITE(*,*) "ERROR IN PI_LEX_SORT! ORDER CAN BE 'I' OR 'D' ONLY!"
			RETURN
		END IF
	CASE('R')
		ALLOCATE(TMP_R_V1(A_DIM(2))); TMP_R_V1=0
		ALLOCATE(TMP_R_A1(2,A_DIM(2))); TMP_R_A1=0
		DO M=1,A_DIM(1)-1
			DO N=1,A_DIM(1)-M
				TMP_R_V1=A(N+1,:)-A(N,:)
				SWAP_MARKER=0
				! CHECK IF SWAP
				DO P=1,A_DIM(2)
					IF (TMP_R_V1(P)>ZERO) THEN
						SWAP_MARKER=1
						EXIT
					ELSE IF (TMP_R_V1(P)<-ZERO) THEN
						SWAP_MARKER=-1
						EXIT
					END IF
				END DO
				
				IF (SWAP_MARKER==-1) THEN
					TMP_R_A1(1,:)=A(N+1,:)
					TMP_R_A1(2,:)=A(N,:)
					A(N:N+1,:)=TMP_R_A1
				END IF
			END DO
		END DO
		IF (ORDER=='D') THEN 
			DEALLOCATE(TMP_R_A1)
			ALLOCATE(TMP_R_A1(A_DIM(1),A_DIM(2))); TMP_R_A1=A
			DO N=1,A_DIM(1)
				A(A_DIM(1)-N+1,:)=TMP_R_A1(N,:)
			END DO
		ELSE IF (ORDER=='I') THEN
		
		ELSE
			WRITE(*,*) "ERROR IN PI_LEX_SORT! ORDER CAN BE 'I' OR 'D' ONLY!"
			RETURN
		END IF
	END SELECT
END SUBROUTINE

! INTEGER LEX SORT =================================================
SUBROUTINE PI_LSORT_IMAT(A,A_DIM,SORT_TYPE,ORDER)
	IMPLICIT NONE
	! DIMENSION 
	INTEGER, INTENT(IN) :: A_DIM(2)
	! INPUT
	CHARACTER(LEN=*) SORT_TYPE, ORDER
	! INPUT / OUTPUT
	INTEGER, INTENT(INOUT) :: A(A_DIM(1),A_DIM(2))
	! LOCAL
	INTEGER :: N, M, P 
	INTEGER :: A_INDEX, SWAP_MARKER
	INTEGER, ALLOCATABLE:: TMP_R_V1(:), TMP_R_A1(:,:)
	
	! VARIABLE INITIALIZATION
	
	! PROGRAM START
	SELECT CASE(SORT_TYPE)
	CASE('C')
		ALLOCATE(TMP_R_V1(A_DIM(1))); TMP_R_V1=0
		ALLOCATE(TMP_R_A1(A_DIM(1),2)); TMP_R_A1=0
		DO M=1,A_DIM(2)-1
			DO N=1,A_DIM(2)-M
				TMP_R_V1=A(:,N+1)-A(:,N)
				SWAP_MARKER=0
				! CHECK IF SWAP
				DO P=1,A_DIM(1)
					IF (TMP_R_V1(P)>0) THEN
						SWAP_MARKER=1
						EXIT
					ELSE IF (TMP_R_V1(P)<0) THEN
						SWAP_MARKER=-1
						EXIT
					END IF
				END DO
				
				IF (SWAP_MARKER==-1) THEN
					TMP_R_A1(:,1)=A(:,N+1)
					TMP_R_A1(:,2)=A(:,N)
					A(:,N:N+1)=TMP_R_A1
				END IF
			END DO
		END DO
		IF (ORDER=='D') THEN 
			DEALLOCATE(TMP_R_A1)
			ALLOCATE(TMP_R_A1(A_DIM(1),A_DIM(2))); TMP_R_A1=A
			DO N=1,A_DIM(2)
				A(:,A_DIM(2)-N+1)=TMP_R_A1(:,N)
			END DO
		ELSE IF (ORDER=='I') THEN
		
		ELSE
			WRITE(*,*) "ERROR IN PI_LEX_SORT! ORDER CAN BE 'I' OR 'D' ONLY!"
			RETURN
		END IF
	CASE('R')
		ALLOCATE(TMP_R_V1(A_DIM(2))); TMP_R_V1=0
		ALLOCATE(TMP_R_A1(2,A_DIM(2))); TMP_R_A1=0
		DO M=1,A_DIM(1)-1
			DO N=1,A_DIM(1)-M
				TMP_R_V1=A(N+1,:)-A(N,:)
				SWAP_MARKER=0
				! CHECK IF SWAP
				DO P=1,A_DIM(2)
					IF (TMP_R_V1(P)>0) THEN
						SWAP_MARKER=1
						EXIT
					ELSE IF (TMP_R_V1(P)<0) THEN
						SWAP_MARKER=-1
						EXIT
					END IF
				END DO
				
				IF (SWAP_MARKER==-1) THEN
					TMP_R_A1(1,:)=A(N+1,:)
					TMP_R_A1(2,:)=A(N,:)
					A(N:N+1,:)=TMP_R_A1
				END IF
			END DO
		END DO
		IF (ORDER=='D') THEN 
			DEALLOCATE(TMP_R_A1)
			ALLOCATE(TMP_R_A1(A_DIM(1),A_DIM(2))); TMP_R_A1=A
			DO N=1,A_DIM(1)
				A(A_DIM(1)-N+1,:)=TMP_R_A1(N,:)
			END DO
		ELSE IF (ORDER=='I') THEN
		
		ELSE
			WRITE(*,*) "ERROR IN PI_LEX_SORT! ORDER CAN BE 'I' OR 'D' ONLY!"
			RETURN
		END IF
	END SELECT
END SUBROUTINE

! VECTOR Bubble Sort ===============================================
! **** PURPOSE **** 
! THIS FUNCTION USING BUBBLE SORT ALGORITHM TO REORDER YOUR ROW VECTOR
! **** INPUT VARIABLES ****
! [A]: REAL, N, YOUR DATA
! [ORDER]: 'I'(INCREASING), 'D'(DECREASING)
! **** OUTPUT VARIABLES ****
! [A]: REAL, N, RESORTTED DATA
! **** VERSION ****
! 1/31/2014 FIRST BUILT 
! **** COMMENT ****
! INPUT AND OUTPUT ARE THE SAME
SUBROUTINE PI_VSORT_R(A,A_DIM,ORDER)
	IMPLICIT NONE
	! DIMENSION 
	INTEGER, INTENT(IN) :: A_DIM
	! INPUT
	CHARACTER(LEN=*) :: ORDER
	! INPUT / OUTPUT
	REAL, INTENT(INOUT) :: A(A_DIM)
	! LOCAL
	INTEGER :: N, M, P 
	REAL :: TMP_R_V(2) 
	
	! VARIABLE INITIALIZATION
	TMP_R_V=0
	
	! PROGRAM START
	DO M=1,A_DIM-1
		DO N=1,A_DIM-M
			SELECT CASE(ORDER)
			CASE('I')
				IF (A(N)>A(N+1)) THEN
					TMP_R_V=(/A(N+1),A(N)/)
					A(N:N+1)=TMP_R_V
				END IF
			CASE('D')
				IF (A(N+1)>A(N)) THEN
					TMP_R_V=(/A(N+1),A(N)/)
					A(N:N+1)=TMP_R_V
				END IF
			END SELECT
		END DO
	END DO
END SUBROUTINE

SUBROUTINE PI_VSORT_I(A,A_DIM,ORDER)
	IMPLICIT NONE
	! DIMENSION 
	INTEGER, INTENT(IN) :: A_DIM
	! INPUT
	CHARACTER(LEN=*) :: ORDER
	! INPUT / OUTPUT
	INTEGER, INTENT(INOUT) :: A(A_DIM)
	! LOCAL
	INTEGER :: N, M, P 
	INTEGER :: TMP_R_V(2) 
	
	! VARIABLE INITIALIZATION
	TMP_R_V=0
	
	! PROGRAM START
	DO M=1,A_DIM-1
		DO N=1,A_DIM-M
			SELECT CASE(ORDER)
			CASE('I')
				IF (A(N)>A(N+1)) THEN
					TMP_R_V=(/A(N+1),A(N)/)
					A(N:N+1)=TMP_R_V
				END IF
			CASE('D')
				IF (A(N+1)>A(N)) THEN
					TMP_R_V=(/A(N+1),A(N)/)
					A(N:N+1)=TMP_R_V
				END IF
			END SELECT
		END DO
	END DO
END SUBROUTINE