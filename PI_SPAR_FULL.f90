! SPARSE MATRIX CONVERTER =====================================================
! **** PURPOSE ****
! THIS CODE CONVERT A SYMMETRY MATRIX TO SPARSE FORM OR VICE VERSA
! **** INPUT/OUTPUT VARIABLES ****
! [A]: REAL, NXN, THE FULL SYMMETRY MATRIX
! [A_SP_IND]: INTEGER, 3X(M+1), THE INDEX OF NON-ZERO ELEMENTS AND ITS CORRESPONDING VALUE
! [A_SP_VAL]: REAL, (M+1), THE VALUES THAT CORRESPONDING TO A_SP_IND(3,:)
! **** VERSION ****
! FEB/5/2014
! **** COMMENT **** 
! 1. EXPLAIN
! THIS CODE AUTO DETECTS THE INPUT AND MAKES THE CONSISTENT FULL MATRIX AND
! SPARSE MATRIX. 
! 2. A_SP_INDEX 
! A_SP_IND IS A 3X(M+1), M IS THE NUMBER NON-ZERO MATRIX ELEMENTS OF THE UPPER
! TRIANGLE WITH THE FORM (INDEX1, INDEX2, VAL_INDEX). 
! (M+1) IS BECAUSE THE FIRST COLUMN JUST RECORDS THE SIZE OF THE FULL
! MATRIX WITH VAL_INDE SET TO 0. 
! 3. A_SP_VAL
! IT RECORDS ALL THE VALUES OF NON-ZERO MATRIX ELEMENTS. THEIR CORRESPONDENCE
! ARE IDENTIFIED BY THE A_SP_IND(3,:).
! IT MAKES THE A_SP_IND AN PURE INTEGER MATRIX WHICH CAN SPEED UP LATER CALCULATIONS
! SO, ALWAYS REGARD A_SP_INDEDX(3,:) AS A REAL VALUE AND NEVER RELABEL IT. ALSO 
! FOR A_SP_VAL, DO REORDER IT. 
! 4. SIZE OF SPARSE MATRIX
! IF YOU DON'T KNOW THE SIZE OF YOUR SPARSE MATRIX IN ADVANCE, USE PI_SYSP_SIZE TO 
! QUERY THE NUMBER NON-ZERO MATRIX. REMEMBER TO +1 WHEN CREATE A SPARSE MATRIX.  
! 5. AUTO DETECTION 
! THIS CODE AUTOMATICALLY DETERMINES WHETHER YOU WANT TO BUILT A SPARSE MATRIX
! OR A FULL MATRIX BASED ON YOUR INPUT. IF YOUR SPARSE CONTAINS INDEX WITH ZERO VALUE
! THE CODE CONSIDER SPARSE ISN'T BUILT AND VICE VERSA. SO, THE FINAL RESULTS ARE 
! ALWAYS CONSISTENT FULL AND SPARSE MATRIX.

SUBROUTINE PI_SYSP_FULL(A,A_DIM,A_SP_IND,A_SP_IND_DIM,A_SP_VAL,A_SP_VAL_DIM)
	IMPLICIT NONE
	! DIMENTISON
	INTEGER, INTENT(IN) :: A_DIM(2), A_SP_IND_DIM(2), A_SP_VAL_DIM
	! INPUT/OUTPUT
	REAL, INTENT(INOUT) :: A(A_DIM(1),A_DIM(2)), A_SP_VAL(A_SP_VAL_DIM)
	INTEGER, INTENT(INOUT) :: A_SP_IND(A_SP_IND_DIM(1),A_SP_IND_DIM(2))
	! LOCAL 
	REAL :: ZERO=0.00001
	INTEGER :: INP_TYPE
	INTEGER :: N, M, COUNTER
	
	
	IF (A_SP_IND(1,1)==A_DIM(1) .AND. A_SP_IND(2,1)==A_DIM(2) .AND. A_SP_IND(3,1)==0) THEN
		INP_TYPE=1 ! SPARSE MATRIX IS BUILT
	ELSE 
		INP_TYPE=0 ! SPARSE MATRIX IS NOT BUILT
	END IF
		
	
	SELECT CASE(INP_TYPE)
	CASE(1)
		A=0
		DO N=2,SIZE(A_SP_VAL)
			A(A_SP_IND(1,N),A_SP_IND(2,N))=A_SP_VAL(A_SP_IND(3,N))
			A(A_SP_IND(2,N),A_SP_IND(1,N))=A_SP_VAL(A_SP_IND(3,N))
		END DO
	CASE(0)
		CALL PI_CLEAN_RMAT(A,A_DIM,ZERO)
		A_SP_IND=0
		A_SP_VAL=0
		A_SP_IND(:,1)=(/A_DIM(1),A_DIM(2),0/)
		COUNTER=1
		DO N=1,A_DIM(1)
			DO M=N,A_DIM(2)
				IF (ABS(A(N,M))>ZERO) THEN
					COUNTER=COUNTER+1
					A_SP_IND(1,COUNTER)=N
					A_SP_IND(2,COUNTER)=M
					A_SP_IND(3,COUNTER)=COUNTER
					A_SP_VAL(COUNTER)=A(N,M)
				END IF
			END DO
		END DO
		
	END SELECT
END SUBROUTINE
	
! HESP ========================================================================	
! **** INPUT/OUTPUT VARIABLES ****
! [A]: COMPLEX, NXN, THE FULL HERMITIAN MATRIX
! [A_SP_IND]: INTEGER, 3XM, THE INDEX OF NON-ZERO ELEMENTS AND ITS CORRESPONDING VALUE
! [A_SP_VAL]: COMPLEX, M,  THE VALUES THAT CORRESPONDING TO A_SP_IND(3,:)
SUBROUTINE PI_HESP_FULL(A,A_DIM,A_SP_IND,A_SP_IND_DIM,A_SP_VAL,A_SP_VAL_DIM)
	IMPLICIT NONE
	! DIMENTISON
	INTEGER, INTENT(IN) :: A_DIM(2), A_SP_IND_DIM(2), A_SP_VAL_DIM
	! INPUT/OUTPUT
	COMPLEX, INTENT(INOUT) :: A(A_DIM(1),A_DIM(2)), A_SP_VAL(A_SP_VAL_DIM)
	INTEGER, INTENT(INOUT) :: A_SP_IND(A_SP_IND_DIM(1),A_SP_IND_DIM(2))
	! LOCAL 
	REAL :: ZERO=0.00001
	INTEGER :: INP_TYPE
	INTEGER :: N, M, COUNTER
	
	
	IF (A_SP_IND(1,1)==A_DIM(1) .AND. A_SP_IND(2,1)==A_DIM(2) .AND. A_SP_IND(3,1)==0) THEN
		INP_TYPE=1 ! SPARSE MATRIX IS BUILT
	ELSE 
		INP_TYPE=0 ! SPARSE MATRIX IS NOT BUILT
	END IF
		
	
	SELECT CASE(INP_TYPE)
	CASE(1)
		A=0
		DO N=2,SIZE(A_SP_VAL)
			A(A_SP_IND(1,N),A_SP_IND(2,N))=A_SP_VAL(A_SP_IND(3,N))
			A(A_SP_IND(2,N),A_SP_IND(1,N))=A_SP_VAL(A_SP_IND(3,N))
		END DO
	CASE(0)
		CALL PI_CLEAN_CMAT(A,A_DIM,ZERO)
		A_SP_IND=0
		A_SP_VAL=0
		A_SP_IND(:,1)=(/A_DIM(1),A_DIM(2),0/)
		COUNTER=1
		DO N=1,A_DIM(1)
			DO M=N,A_DIM(2)
				IF (ABS(A(N,M))>ZERO) THEN
					COUNTER=COUNTER+1
					A_SP_IND(1,COUNTER)=N
					A_SP_IND(2,COUNTER)=M
					A_SP_IND(3,COUNTER)=COUNTER
					A_SP_VAL(COUNTER)=A(N,M)
				END IF
			END DO
		END DO
		
	END SELECT
END SUBROUTINE