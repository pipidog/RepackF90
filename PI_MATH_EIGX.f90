! PI_EIG_RMAT =================================================================
! **** PURPOSE ****
! THIS CODE DIAGONALIZE A SYMMETRY/HERMITIAN MATRIX USING BI-SECTION-INVERSE-ITERATION 
! ALGORITHM IN LAPACK (SSYEVX,CHEEVX)
! **** INPUT VARIABLES ****
! [A]: REAL, NXN, THE MATRIX TO BE DIAGONALIZED  
! [LB]: REAL, 1, THE LOWER BOUND OF YOUR EIGENSTATE
! [UB]: REAL, 1, THE UPPER BOUND OF YOUR EIGENSTATE
! [BOUND_OPT]: 'A'(ALL),'I'(INDEX),'V'(VALUE)
! **** OUTPUT VARIABLES ****
! [EVAL]: REAL, N, THE EIGENVALUES 
! [EVEC]: REAL, NXM, EIGENVETORS
! **** VERSION ****
! 2/6/2014 FIRST BUILT 
! **** COMMENT **** 
! 1. LB, UP
! IF BOUND_OPT='A', THEY ARE NOT REFERENCE. IF 'I', THEY WILL BE CONSIDER
! AS EIGENVALUE INDEX. NINT(LB), NINT(UB) WILL BE TAKEN. IF 'V', THEY WILL
! BE CONSIDER AS VALUES.

SUBROUTINE PI_EIGX_SYMAT(A,A_DIM,BOUND,BOUND_OPT,TOT_EIG,EVAL,EVAL_DIM,EVEC,EVEC_DIM)
	IMPLICIT NONE
	! DIMENSION 
	INTEGER, INTENT(IN) :: A_DIM(2), EVAL_DIM, EVEC_DIM(2)
	! INPUT
	REAL, INTENT(IN) :: A(A_DIM(1),A_DIM(2)), BOUND(2)
	CHARACTER(LEN=*), INTENT(IN) :: BOUND_OPT 
	! OUTPUT
	INTEGER, INTENT(OUT) :: TOT_EIG
	REAL, INTENT(OUT) :: EVAL(EVAL_DIM), EVEC(EVEC_DIM(1),EVEC_DIM(2))
	! LOCAL(VALUE)
	INTEGER :: LWORK, INFO
	! LOCAL(ARRAY)
	INTEGER :: IWORK(5*A_DIM(1)), IFAIL(A_DIM(1))
	! ALLOCATABEL
	REAL, ALLOCATABLE :: WORK(:)
	
	IF (EVAL_DIM/=A_DIM(1)) THEN
		WRITE(*,*) "ERROR IN PI_EIGR_SYMAT! DIMENSIONS ARE INCONSISTENT!"
	END IF
	
	
	ALLOCATE(WORK(1))
	LWORK=-1
	CALL SSYEVX('V',BOUND_OPT,'U',A_DIM(1),A,A_DIM(1),BOUND(1),BOUND(2)&
	&,NINT(BOUND(1)),NINT(BOUND(2)),-1.0,TOT_EIG,EVAL&
	&,EVEC,EVEC_DIM(1),WORK,LWORK,IWORK,IFAIL,INFO)
	
	LWORK=NINT(WORK(1))+1
	DEALLOCATE(WORK)
	ALLOCATE(WORK(LWORK))
	
	CALL SSYEVX('V',BOUND_OPT,'U',A_DIM(1),A,A_DIM(1),BOUND(1),BOUND(2)&
	&,NINT(BOUND(1)),NINT(BOUND(2)),-1.0,TOT_EIG,EVAL&
	&,EVEC,EVEC_DIM(1),WORK,LWORK,IWORK,IFAIL,INFO)
	
	IF (INFO/=0) THEN
		WRITE(*,*) "ERROR IN PI_EIGR_SYMAT! INFO/=0!"
		RETURN
	END IF
END SUBROUTINE
	
! PI_EIG_RMAT =================================================================
! **** INPUT VARIABLES ****
! [A]: COMPLEX, NXN, THE MATRIX TO BE DIAGONALIZED  
! [LB]: REAL, 1, THE LOWER BOUND OF YOUR EIGENSTATE
! [UB]: REAL, 1, THE UPPER BOUND OF YOUR EIGENSTATE
! **** OUTPUT VARIABLES ****
! [EVAL]: REAL, N, THE EIGENVALUES 
! [EVEC]: COMPLEX, NXM, EIGENVETORS

SUBROUTINE PI_EIGX_HEMAT(A,A_DIM,BOUND,BOUND_OPT,TOT_EIG,EVAL,EVAL_DIM,EVEC,EVEC_DIM)
	IMPLICIT NONE
	! DIMENSION 
	INTEGER, INTENT(IN) :: A_DIM(2), EVAL_DIM, EVEC_DIM(2)
	! INPUT
	COMPLEX, INTENT(IN) :: A(A_DIM(1),A_DIM(2)) 
	REAL, INTENT(IN) :: BOUND(2)
	CHARACTER(LEN=*), INTENT(IN) :: BOUND_OPT 
	! OUTPUT
	INTEGER, INTENT(OUT) :: TOT_EIG
	REAL, INTENT(OUT) :: EVAL(EVAL_DIM) 
	COMPLEX, INTENT(OUT) :: EVEC(EVEC_DIM(1),EVEC_DIM(2))
	! LOCAL(VALUE)
	INTEGER :: LWORK, INFO
	! LOCAL(ARRAY)
	INTEGER :: IWORK(5*A_DIM(1)), IFAIL(A_DIM(1))
	REAL :: RWORK(7*A_DIM(1))
	! ALLOCATABEL
	COMPLEX, ALLOCATABLE :: WORK(:)
	
	IF (EVAL_DIM/=A_DIM(1)) THEN
		WRITE(*,*) "ERROR IN PI_EIGR_HEMAT! DIMENSIONS ARE INCONSISTENT!"
	END IF
	
	ALLOCATE(WORK(1))
	LWORK=-1
	CALL CHEEVX('V',BOUND_OPT,'U',A_DIM(1),A,A_DIM(1),BOUND(1),BOUND(2)&
	&,NINT(BOUND(1)),NINT(BOUND(2)),-1,TOT_EIG,EVAL&
	&,EVEC,EVEC_DIM(1),WORK,LWORK,RWORK,IWORK,IFAIL,INFO)
	LWORK=NINT(REAL(WORK(1)))+1
	DEALLOCATE(WORK)
	ALLOCATE(WORK(LWORK))
	
	CALL CHEEVX('V',BOUND_OPT,'U',A_DIM(1),A,A_DIM(1),BOUND(1),BOUND(2)&
	&,NINT(BOUND(1)),NINT(BOUND(2)),-1,TOT_EIG,EVAL&
	&,EVEC,EVEC_DIM(1),WORK,LWORK,RWORK,IWORK,IFAIL,INFO)
	
	IF (INFO/=0) THEN
		WRITE(*,*) "ERROR IN PI_EIGR_SYMAT! INFO/=0!"
		RETURN
	END IF
END SUBROUTINE
