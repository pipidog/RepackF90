! THIS FILE CONTAINS ALL HAMILTONIAN RELATED SUBROUTINES 
! FOCK STATE ==================================================================  
! **** PURPOSE ****
! GENERATES THE FERMION FOCK STATE 
! **** INPUT VARIABLES ****
! [OCCUP_NUM]: INTEGER, 2XN, TELLS THE LEVELS AND PT # OF EACH SITE
! [OUT_FORM]: STRING, 'SITE' OR 'TOTAL', DECIDE HOW WILL YOU LABEL THE STATE
! **** OUTPUT VARIABLES ****
! [FOCK_OCCUP]: INTEGER, SUM(OCCUP_NUM(2,:))X(C(5,2)XC(4,2)), SHOW OCCUPIED STATES
! **** VERSION ****
! 1/20/2014 FIRST BUILT 
! 1/28/2014 ADD FUNCTION TO DEAL WITH FULL EMPTY CASE 
! **** COMMENT **** 
! 1. SCENARIO 
! THE OCCUP_NUM HAS THE FORM, EX: [5,2;4,2], WHICH MEANS YOU HAVE 5 LEVELS AT
! SITE-1 WITH 2 PARTICLE IN IT AND SO ON. THE OUTPUT WILL GIVE YOU THE WHICH
! STATES ARE OCCUPIED. THE STATE ARE LABELED IN TOTAL STATE SERIES. SO, FOR
! THIS CASE, SITE-1:1~5, SITE-2:6~9 AND OBVIOUSLY, THE SIZE OF FOCK_STATE IS
! (TOTAL PARTICLE)X(TOTAL PERMUTAION)
! 2. OVERSIZE PROBLEM (PARTICLE-HOLE TRANSFORMATION)
! THE COMBINATORIAL PROBLEM GOES TO EXTREMELY LARGE QUICKLY. TO AVIOD TIS ISSUE,
! TRY TO USE PARTICLE-HOLE ALTERNATIVE LANGUAGE FOR YOUR PROBLEM. EX: UING C(14,4)
! INTTEAD OF C(14,10) WHICH MEANS YOU TAKE OFF 4 PARTICLES RATHER THAN ADDING 10
! PARTICLES. IT WILL HIGHLY REDUCE THE LOADING. HOWEVER, KEEP IN MIND WHAT YOU
! ARE USING! 
! 3. OUT_FORM
! IF 'SITE', THE CODE WILL LABEL THE STATES OF EACH SITE FROM 1. IF 'TOTAL', THE
! CODE WILL LABLE EACH SITE FORM 1 TO TOTAL STATE. EX: OCCUP_NUM=[5,3,4,3], THEN
! STATE LABLE WILL BE 1-5 ON SITE 1 AND 6-9 ON SITE 2.
! IT IS STRONGLY RECOMMMEND TO USE 'TOTAL' WHICH IS COMPATIBLE FOR FURTHER
! CALCULATIONS. THE 'SITE' OPTION IS DESIGNED TO SOLVE THE COMBINATORIAL PROBLEM. 
! 4. FORAML FOCK STATE
! THIS CODE JUST HELPS YOU FIGURE OUT THE OCCUPIED STATES FOR TWO REASONS. (1)
! SAVE THE MEMORY (2) ABILITY FOR USE AS A CODE THAT OUTPUTS YOU THE C(N,M) PROBLEM
! IF YOU NEED TO USE OTHER FOCK STATE PROBLEMS, YOU SHOULD USE PI_FOCK_CONVERT
! TO GENERATE REAL FOCK STATE REPRESENTATION

SUBROUTINE PI_FOCK_OCCUP(OCCUP_NUM,OCCUP_NUM_DIM,FOCK_OCCUP,FOCK_OCCUP_DIM,OUT_FORM)
  IMPLICIT NONE
  ! DIMENSION
  INTEGER, INTENT(IN) :: OCCUP_NUM_DIM(2), FOCK_OCCUP_DIM(2)
  ! INPUT   
  CHARACTER(*), INTENT(IN) :: OUT_FORM
  INTEGER, INTENT(IN) :: OCCUP_NUM(OCCUP_NUM_DIM(1),OCCUP_NUM_DIM(2))
  ! OUTPUT
  INTEGER, INTENT(OUT) :: FOCK_OCCUP(FOCK_OCCUP_DIM(1),FOCK_OCCUP_DIM(2))
  ! LOCAL(DUMMY)
  INTEGER :: N, M, P
  ! LOCAL (VALUES) 
  INTEGER :: TOT_SITE=0, TOT_PT=0, TMP_COUNT=0 
  INTEGER :: LOOP_INDEX_TEST=0, TOT_COMB=0, COMB=0 
  ! LOCAL (ARRAYS)
  ! N/A
  ! LOCAL(ALLOVATABLES)
  INTEGER, ALLOCATABLE :: LOOP_INDEX(:,:), LOOP_END(:), SITE_LEVEL_RANGE(:,:), OCCUP_NZ(:,:)
  ! VARIABLES INITIALIZATION
  FOCK_OCCUP=0
  ! PROGRAM START ---------------------------------------
  
  ! GENERATES OCCUP_NUM_NZ (OCCUP_NUM THAT HAS NO ZERO FILL SITE)
  ALLOCATE(OCCUP_NZ(2,COUNT(OCCUP_NUM(2,:)/=0))); OCCUP_NZ=0
  TMP_COUNT=0
  
  DO N=1,OCCUP_NUM_DIM(2)
	IF (OCCUP_NUM(2,N)/=0) THEN
		TMP_COUNT=TMP_COUNT+1
		OCCUP_NZ(:,TMP_COUNT)=OCCUP_NUM(:,N)
	END IF
  END DO

  ! GENERATES ALL NECESSARY VARIABLES
  TOT_SITE=SIZE(OCCUP_NZ,2)
  TOT_PT=SUM(OCCUP_NZ(2,:))
  TOT_COMB=FOCK_OCCUP_DIM(2)
  ALLOCATE(LOOP_END(TOT_PT)); LOOP_END=0  
  ALLOCATE(SITE_LEVEL_RANGE(2,TOT_SITE)); SITE_LEVEL_RANGE=0 
    
  DO N=1,TOT_SITE
   SELECT CASE(N)
     CASE(1)
      SITE_LEVEL_RANGE(1,N)=1
     CASE DEFAULT
      SITE_LEVEL_RANGE(1,N)=SITE_LEVEL_RANGE(2,N-1)+1
   END SELECT
   SITE_LEVEL_RANGE(2,N)=SITE_LEVEL_RANGE(1,N)+OCCUP_NZ(2,N)-1
  END DO
  
  ! GENERATES LOOP_END VECTOR
  TMP_COUNT=0
  DO N=1,TOT_SITE
    DO M=1,OCCUP_NZ(2,N)
      TMP_COUNT=TMP_COUNT+1
      LOOP_END(TMP_COUNT)=OCCUP_NZ(1,N)     
    END DO
  END DO
  ALLOCATE(LOOP_INDEX(TOT_PT,PRODUCT(LOOP_END))) ; LOOP_INDEX=0
  CALL PI_NESTED_LOOP(LOOP_END,SHAPE(LOOP_END),LOOP_INDEX,SHAPE(LOOP_INDEX))
  
  ! KICK OUT UNWANTED LOOP_INDEX
  TMP_COUNT=0
  DO N=1,PRODUCT(LOOP_END)
    LOOP_INDEX_TEST=1
        
    DO M=1,TOT_SITE
       IF (SITE_LEVEL_RANGE(1,M)/=SITE_LEVEL_RANGE(2,M)) THEN 
         DO P=SITE_LEVEL_RANGE(1,M)+1,SITE_LEVEL_RANGE(2,M)
          IF (ANY(LOOP_INDEX(SITE_LEVEL_RANGE(1,M):P-1,N)>=LOOP_INDEX(P,N))) THEN 
            LOOP_INDEX_TEST=-1
            EXIT
          END IF
         END DO
       END IF
      IF (LOOP_INDEX_TEST==-1) THEN
        EXIT
      END IF
   END DO    
     IF (LOOP_INDEX_TEST==1) THEN
       TMP_COUNT=TMP_COUNT+1
       FOCK_OCCUP(:,TMP_COUNT)=LOOP_INDEX(:,N)
     END IF
  END DO
  
  SELECT CASE(OUT_FORM)
  CASE('SITE')
  
  CASE('TOTAL')
    IF (TOT_SITE>1) THEN
      DO N=2,TOT_SITE
        FOCK_OCCUP(SITE_LEVEL_RANGE(1,N):SITE_LEVEL_RANGE(2,N),:)&
        &=FOCK_OCCUP(SITE_LEVEL_RANGE(1,N):SITE_LEVEL_RANGE(2,N),:)+SUM(OCCUP_NZ(1,1:N-1))
      END DO
    END IF
  CASE DEFAULT
     WRITE(*,*) "OUT_FORM ERROR IN PI_FOCK_OCCUP! CHANGE TO 'SITE' OPTION! "
  END SELECT 


  !RELABEL SITE NUMBER BASED ON EMPTY FILL
  TMP_COUNT=0 ! COUNT NON-ZERO SITE
  DO N=1,OCCUP_NUM_DIM(2)-1
	IF (OCCUP_NUM(2,N)==0) THEN
		FOCK_OCCUP(SITE_LEVEL_RANGE(1,TMP_COUNT+1):,:)&
		&=FOCK_OCCUP(SITE_LEVEL_RANGE(1,TMP_COUNT+1):,:)+OCCUP_NUM(1,N)
	ELSE
		TMP_COUNT=TMP_COUNT+1
	END IF
  END DO
END SUBROUTINE